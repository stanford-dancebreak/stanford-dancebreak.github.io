#!/bin/bash
#
# Usage:
#
#      .git/hooks/pre-commit
#
# Pre-commit hook, automatically invoked by "git commit" (with no
# arguments).  Can also be invoked to run pre-commit check
# manually as follows:
#
#      .git/hooks/pre-commit --all-files
#
#      .git/hooks/pre-commit <file1> ...
#
# If "-all-files" is specified as the first argument, all files
# in the current directory and in all subdirectories are checked.
# (All other arguments are ignored.)  Otherwise, the specified
# files are checked.
#
# Exits with non-zero status if an issue that should abort the
# commit is detected.  (An error message is issued to standard
# error for each detected problem.)  Issues checked for are:
#
#      1.  Problematic filenames.
#
#          Filenames must not contain characters which may be
#          treated as "special" by a shell, or white space
#          characters.  For safety, they are limited to:
#
#               --  Letters [A-Za-z]
#               --  Numbers [0-9]
#               --  Certain symbols [-._]
#
#          They must also not start with a dash.
#
#      2.  Tabs.
#
#          Tabs are not permitted in source files.  Space
#          characters must be used for indentation.
#
#      3.  End-of-line spaces.
#
#          Lines should not end with space characters.
#
#      4.  Blank lines at end of file.
#
#          There should be no blank lines at the end of the file.
#
# NOTE:  although the script attempts to detect all issues, this
# may not be possible with one invocation.  In particular, the
# filename check is in part to make subsequent for-loops over the
# changed/new files simpler.  If it is run manually, then it
# should be re-run after correcting issues (this is done
# automatically by "git commit").
#
# If the commit may proceed, then the script exits with zero
# status, with no messages issued.
#
# Bob Carragher
# Mon Sep  3 20:02:23 PDT 2018

# Note:  CHECK_FILES is set in check #1.  See the check's header
# comments for the reason.
CHECK_FILES=()
if [[ $# -gt 0 ]]; then
    if [[ "$1" = "--all-files" ]]; then
        # To guard against filenames with weird characters,
        # particularly white space, which makes it hard to detect
        # within Bash where one filename ends and the next
        # starts, we will use the -print0 find(1) directive,
        # which uses the null character ("\0") to separate file
        # paths.  This cannot easily be used with a Bash
        # variable, so we'll generate the filenames and pipe the
        # results directly into the while-loop.  All good
        # filenames will be added to CHECK_FILES.
        FILENAME_CHECK_STYLE="all_files"
    else
        CHECK_FILES=( "$@" )
        FILENAME_CHECK_STYLE="specified"
    fi
else
    # Note:  avoid checking deleted files.
    CHECK_FILES=( $( git diff --staged --diff-filter=ACMRTUXB --name-only ) )
    FILENAME_CHECK_STYLE="git_diff"
fi

if [[ (${#CHECK_FILES[@]} -eq 0) &&
      ($FILENAME_CHECK_STYLE != "all_files") ]]; then
    # No new files; nothing to check.
    echo no files to check, early exit
    exit 0
fi

error_exit() {
    (
        cat<<'ERROR_EXIT_EXPLANATION'
=================================================================
This report output resulted from the invocation of the pre-commit
check script, which scans for potential problems and helps
maintain a consistent file content style.  It is located under
     .git/hooks/pre-commit
and is always run when "git commit" is invoked.  You can directly
run this script, using (with no arguments):
     $ .git/hooks/pre-commit
If there are no problems, then the script exits with no output.
You may also apply it to specific files using
     $ .git/hooks/pre-commit <file1> ...
or all files (other than in the .git/ subdirectory) using
     $ .git/hooks/pre-commit --all-files
.................................................................
TIP:  if the script does not seem to be checking anything, are
you always supplying "-a" to the "git commit" invocation?  I.e.
     $ git commit -a
In that case, you must first stage the files so that this script
will see them, for example with:
     $ git add <new_or_modified_file> ...
Or just directly check the file:
     $ .git/hooks/pre-commit <new_or_modified_file>
ERROR_EXIT_EXPLANATION
    ) 1>&2
    exit $1
}

CHECK_DECLARATION=
CHECK_EXPLANATION=
report_issues() {
    # Temporarily redirect standard output to standard error so
    # that everything goes there, without needing to redirect
    # the output of every line.
    exec 4<&1
    exec 1>&2
    echo .................................................................
    echo "$CHECK_DECLARATION"
    for ll in "$@"; do
        echo "$ll" | sed 's/^/     /'
    done
    echo "$CHECK_EXPLANATION"
    # Restore standard output and close FD #4.
    exec 1<&4
    exec 4<&-
}

#################################################################
# 1.  Filename check.
#
# If there are any failures here, then exit the script, which
# expects filenames to not use weird characters.
read -r -d '' CHECK_DECLARATION <<'CHECK_DECLARATION_EOF'
Bad filename check -- the following filename(s) have problems:
CHECK_DECLARATION_EOF
read -r -d '' CHECK_EXPLANATION <<'CHECK_EXPLANATION_EOF'
To avoid problems across platforms, filenames are allowed to
contain only letters (A-Z, a-z), numbers (0-9), and the following
symbols:  dash ("-"), underscore ("_"), and period (".").  They
must also begin with either a letter or number.  Please rename
your files, using for example:
     git mv <old-name> <new-name>
WARNING:  EXITING CHECK SCRIPT -- NO FURTHER CHECKS APPLIED!
CHECK_EXPLANATION_EOF
is_bad_filename() {
    # Note:  the path-component separator "/" character is
    # included in the "allowed" set, since it is never allowed to
    # be part of a path's component, but will be present in file
    # paths not at the current directory level.
    if [[ "$1" =~ [^-_\./0-9A-Za-z] ]]; then
        return 0
    else
        # File (and directory) names cannot start a dash ("-").
        local REMAINING="$1"
        while [[ "$REMAINING" != . ]]; do
            if [[ "$( basename -- "$REMAINING" )" =~ ^- ]]; then
                # Path components cannot start a dash ("-").
                return 0
            fi
            REMAINING=$( dirname -- "$REMAINING" )
        done
    fi
    return 1
}
BAD_FILENAMES=()
if [[ $FILENAME_CHECK_STYLE == "all_files" ]]; then
    # Use the -print0 find(1) directive to generate a single
    # string consisting of all the found files, separated by the
    # null character ("\0").  This guarantees that we will use
    # the correct filename, regardless of possible white space or
    # other weird characters, since the null character (and the
    # slash character ["/"], for path component separation) is
    # not allowed in filenames.
    #
    # Meanwhile, build up CHECK_FILES so that it contains the
    # good filenames, which the rest of the script will expect if
    # this check passes.
    #
    # NOTE:  "lastpipe" is used to force the execution of the
    # last command of a pipeline (in this case, the entire
    # while-loop) in the current shell, rather than in the
    # background.  This allows global variables to be updated
    # within the while-loop.
    shopt -s lastpipe
    find . -name .git -prune -o -type f -print0 |
    while IFS= read -r -d '' ff_0; do
        if is_bad_filename "$ff_0"; then
            BAD_FILENAMES+=( "$ff_0" )
        else
            CHECK_FILES+=( "$ff_0" )
        fi
    done
    shopt -u lastpipe
else
    # CHECK_FILES is an array of strings, which may contain white
    # space.  Simple double-quoting suffices to protect the
    # index variable.
    for ff in "${CHECK_FILES[@]}"; do
        if is_bad_filename "$ff"; then
            BAD_FILENAMES+=( "$ff" )
        fi
    done
fi
if (( ${#BAD_FILENAMES[@]} != 0 )); then
    report_issues "${BAD_FILENAMES[@]}"
    error_exit 1
fi
##=============================================================##
# Check file existence.
#
# If the filenames were specified, then verify that they
# correspond to existing files.
read -r -d '' CHECK_DECLARATION <<'CHECK_DECLARATION_EOF'
File existence check -- the following file(s) do not exist:
CHECK_DECLARATION_EOF
read -r -d '' CHECK_EXPLANATION <<'CHECK_EXPLANATION_EOF'
WARNING:  EXITING CHECK SCRIPT -- NO FURTHER CHECKS APPLIED!
CHECK_EXPLANATION_EOF
if [[ $FILENAME_CHECK_STYLE == "specified" ]]; then
    NONEXISTENT_FILENAMES=()
    for ee in ${CHECK_FILES[@]}; do
        if [ ! -e $ee ]; then
            NONEXISTENT_FILENAMES+=( $ee )
        fi
    done
    if (( ${#NONEXISTENT_FILENAMES[@]} != 0 )); then
        report_issues "${NONEXISTENT_FILENAMES[@]}"
        error_exit 1
    fi
fi

#################################################################
# The rest of the checks apply only to text files, so all other
# file types may be excluded.
CHECK_TEXT_FILES=( $( printf '%s\n' ${CHECK_FILES[@]} | \
                      egrep -v '\.(gif|jpg|pdf|png)$' ) )

#################################################################
# The rest of the checks do not require immediate exit from the
# script if a problem is detected, and so all may be run.
EXIT_VALUE=0  # Optimism ....

##=============================================================##
# 2.  Tabs check.
read -r -d '' CHECK_DECLARATION <<'CHECK_DECLARATION_EOF'
Tabs check -- the following file(s) contain tab(s):
CHECK_DECLARATION_EOF
read -r -d '' CHECK_EXPLANATION <<'CHECK_EXPLANATION_EOF'
Tabs are not permitted in text files.  Please remove them from
the listed files (at the indicated line number), either by
converting them to an appropriate number of space characters, or
deleting them entirely.
CHECK_EXPLANATION_EOF
TAB_FILES=$( grep -n -H $'\t' ${CHECK_TEXT_FILES[@]} )
if [ -n "$TAB_FILES" ]; then
    report_issues "${TAB_FILES[@]}"
    EXIT_VALUE=1
fi

##=============================================================##
# 3.  End-of-line spaces check.
#
# Note that the "^M*" portion of the grep(1) search string is to
# handle the difference between Unix-format and DOS-format text
# file line endings (LF, or in hex 0x0A; versus CR+LF, 0x0D0A).
read -r -d '' CHECK_DECLARATION <<'CHECK_DECLARATION_EOF'
End-of-line spaces check -- the following file(s) contain 1 or
more spaces at the end of line(s):
CHECK_DECLARATION_EOF
read -r -d '' CHECK_EXPLANATION <<'CHECK_EXPLANATION_EOF'
Lines in text files may not end with spaces.  Please remove them
from the listed files (at the indicated line number).
CHECK_EXPLANATION_EOF
SPACE_FILES=$( grep -n -H '  **$' ${CHECK_TEXT_FILES[@]} )
if [ -n "$SPACE_FILES" ]; then
    report_issues "${SPACE_FILES[@]}"
    EXIT_VALUE=1
fi

##=============================================================##
# 4.  Blank lines at end of file check.
#
# As a hack, we only detect whether the last line is blank (or
# contains just whitespace), as that implies there is at least 1
# trailing blank line in the file.  As with check #3, above, "^M"
# is used with the end-of-line portion of the search string.
read -r -d '' CHECK_DECLARATION <<'CHECK_DECLARATION_EOF'
Blank lines at end of file check -- the following file(s) contain
1 or more blank lines at their end:
CHECK_DECLARATION_EOF
read -r -d '' CHECK_EXPLANATION <<'CHECK_EXPLANATION_EOF'
Text files may not contain blank lines at their end.  Please
delete the blank line(s) from the listed files.
CHECK_EXPLANATION_EOF
BLANK_LINE_FILES=()
for ff in ${CHECK_TEXT_FILES[@]}; do
    if [ -n "$( tail -1 $ff | grep '^ **$' )" ]; then
        BLANK_LINE_FILES+=( $ff )
    fi
done
if (( ${#BLANK_LINE_FILES[@]} != 0 )); then
    report_issues "${BLANK_LINE_FILES[@]}"
    EXIT_VALUE=1
fi

#################################################################
# End of script.  Use error_exit() function if a problem was
# spotted, as it provides explanations and hints to the user.
if (( EXIT_VALUE != 0 )); then
    error_exit $EXIT_VALUE
fi
exit 0
